// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var concat, cons, empty, head, isParsingError, last, makeParsingInstance, parserListToString, parsingError, tail, util,
    __slice = [].slice;

  util = Object.freeze({
    "y": function(le) {
      return (function(f) {
        return f(f);
      })(function(f) {
        return le(function() {
          var args, _ref;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return (_ref = f(f)).call.apply(_ref, [this].concat(__slice.call(args)));
        });
      });
    },
    "loop": function(f) {
      return util.y(f)();
    },
    "makeObject": function(proto, ownProps) {
      var prop, result, val;
      result = Object.create(proto);
      for (prop in ownProps) {
        val = ownProps[prop];
        if (ownProps.hasOwnProperty(prop)) {
          result[prop] = val;
        }
      }
      return result;
    },
    "typeOf": function(x) {
      if (Array.isArray(x)) {
        return "array";
      } else if (Object.prototype.toString.call(x) === "[object RegExp]") {
        return "regexp";
      } else if (x === null) {
        return "null";
      } else {
        return typeof x;
      }
    }
  });

  cons = function(x, xs) {
    return [x].concat(__slice.call(xs));
  };

  head = function(xs) {
    return xs[0];
  };

  tail = function(xs) {
    return xs.slice(1);
  };

  last = function(xs) {
    return xs[xs.length - 1];
  };

  empty = function(l) {
    return l.length === 0;
  };

  concat = function(xs, ys) {
    return xs.concat(ys);
  };

  parsingError = function(msg) {
    return {
      "name": "Parsing Error",
      "msg": msg
    };
  };

  isParsingError = function(err) {
    return (err != null ? err.name : void 0) === "Parsing Error";
  };

  makeParsingInstance = (function() {
    var isParser, makeSureParser, parserUsage, proto;
    isParser = function(x) {
      return util.typeOf(x) === "function" && x.isParser;
    };
    makeSureParser = function(x) {
      if (isParser(x)) {
        return x;
      } else {
        return makeParser(x);
      }
    };
    parserUsage = function(which) {
      return function(a, b, c) {
        var other, prsr, _ref;
        if ((_ref = util.typeOf(a)) === "number" || _ref === "null" || _ref === "undefined") {
          this["throw"]("Invalid argument to @" + which + ".\n\nJSON.stringify(the argument) is " + (JSON.stringify(a)) + ".\n\n\nString(the argument) is " + a);
        }
        if (util.typeOf(a) === "object") {
          prsr = makeSureParser(a.lookFor);
          other = a;
        } else if (util.typeOf(b) === "object") {
          prsr = makeSureParser(a);
          other = b;
        } else {
          prsr = makeSureParser(a);
          other = {
            found: b,
            notFound: c,
            args: []
          };
        }
        if (which === "optional") {
          if (other.notFound == null) {
            other.notFound = function() {};
          }
        }
        return prsr.requireFor(this, other);
      };
    };
    proto = Object.freeze({
      "loop": util.loop,
      "beginsWith": function(s) {
        if (util.typeOf(this.str.startsWith) === "function") {
          return this.str.slice(this.index).startsWith(s);
        } else {
          return this.loop((function(_this) {
            return function(repeat) {
              return function(i) {
                if (i == null) {
                  i = _this.index;
                }
                if (_this.str.slice(0, i + 1) === s) {
                  return true;
                } else {
                  return repeat(i + 1);
                }
              };
            };
          })(this));
        }
      },
      "char": function(x) {
        if (x == null) {
          x = 0;
        }
        return this.str[this.index + x];
      },
      "soFar": function() {
        return this.str.slice(this.startIndex, this.index);
      },
      "until": function(x) {
        if (util.typeOf(x) === "string") {
          return this.str.slice(this.index, this.str.indexOf(x, this.index));
        } else {
          return this.str.slice(this.index, this.index + x);
        }
      },
      "test": function(prsr) {
        return !!(prsr.opt()(this.str, {
          startAt: this.index
        }));
      },
      "advance": function(x) {
        return this.index += (function() {
          switch (util.typeOf(x)) {
            case "string":
              return x.length;
            case "number":
              return x;
            case "undefined":
              return 1;
          }
        })();
      },
      "advancePast": function(s) {
        while (!this.beginsWith(s)) {
          this.advance();
        }
        return this.advance(s);
      },
      "throw": function(msg) {
        throw parsingError(msg);
      },
      "reqBool": function(bool, err) {
        if (!bool) {
          throw parsingError(err != null ? err : "Test to @reqBool failed.");
        }
      },
      "caseParse": function(o, onNoMatch) {
        return this.loop((function(_this) {
          return function(repeat) {
            return function(keys) {
              var fn;
              if (keys == null) {
                keys = Object.keys(o);
              }
              if (empty(keys)) {
                if (onNoMatch) {
                  return onNoMatch();
                } else {
                  return _this["throw"]("Expected one of the following: " + JSON.stringify(Object.keys(o), null, 4));
                }
              } else {
                fn = o[head(keys)];
                return _this.optional(head(keys), {
                  found: function() {
                    if (fn.isParser) {
                      return _this.require(fn);
                    } else {
                      return fn();
                    }
                  },
                  notFound: function() {
                    return repeat(tail(keys));
                  }
                });
              }
            };
          };
        })(this));
      },
      "white": function(req) {
        if (req === "req") {
          return this.require(makeParser.getWhite);
        } else {
          return this.optional(makeParser.getWhite);
        }
      },
      "optional": parserUsage("optional"),
      "require": parserUsage("require"),
      "end": function() {
        if (this.char() !== void 0) {
          throw parsingError("Expected end of input, instead found '" + (this.char()) + "'");
        }
      }
    });
    return function(str, i) {
      if (i == null) {
        i = 0;
      }
      if (util.typeOf(str) !== "string") {
        throw new Error("First argument to a parser must be a string. Instead,\n" + str + "\nof type " + (util.typeOf(str)) + " was found.");
      }
      return util.makeObject(proto, {
        "index": i,
        "str": str,
        "startIndex": i
      });
    };
  })();

  parserListToString = function(arr) {
    return util.loop((function(_this) {
      return function(repeat) {
        return function(options, str) {
          var x;
          if (options == null) {
            options = arr;
          }
          if (str == null) {
            str = "[";
          }
          if (empty(options)) {
            return str.slice(0, -2) + "]";
          } else {
            x = head(options);
            switch (util.typeOf(x)) {
              case "function":
                if (x.isParser) {
                  return repeat(tail(options), str + ("" + x.parserName + ", "));
                } else {
                  return repeat(tail(options), str + "(not-yet-named fn parser), ");
                }
                break;
              case "regexp":
                return repeat(tail(options), str + x.toString() + ", ");
              case "undefined":
                return repeat(tail(options), str + "(undefined), ");
              default:
                return repeat(tail(options), str + JSON.stringify(x) + ", ");
            }
          }
        };
      };
    })(this));
  };

  this.makeParser = function() {
    var args, name, parser, useParserAbstraction, x;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length > 1) {
      name = args[0];
      x = args[1];
    } else if (args.length === 1) {
      x = args[0];
    } else {
      throw new Error("makeParser requires arguments");
    }

    /* Overloads of x in -makeParser-:
        string:          x is the string to be required
        array:           x is a list of options, where one must match. Earlier elements have higher precedence.
        regexp:          if the string doesn't match x, it throws, otherwise x.exec(@str) is skipped returned.
        parser-function: x is just returned
        plain function:  x is used to make a parser-function. (Returns a NEW function that is a parser
                          function which USES the input function by applying it to an instance. It also
                          sets some methods (requireFor, ...) and sets .isParser to true).
     */
    if (util.typeOf(x) === "string") {
      return makeParser(name != null ? name : "string-form-parser: " + (JSON.stringify(x)), function() {
        if (this.beginsWith(x)) {
          this.advance(x.length);
          return this.soFar();
        } else {
          return this["throw"]("Expected \"" + x + "\" at index " + this.index + " and instead found " + (this.char()) + " in string:\n" + (JSON.stringify(this.str)));
        }
      });
    } else if (util.typeOf(x) === "array") {
      return makeParser(name != null ? name : "array-form-parser: " + (parserListToString(x)), function(args) {
        var errors;
        errors = [];
        return this.loop((function(_this) {
          return function(repeat) {
            return function(i, errors) {
              if (i == null) {
                i = 0;
              }
              if (errors == null) {
                errors = [];
              }
              if (i >= x.length) {
                _this["throw"]("(From " + name + ") Expected one of the following: " + (parserListToString(x)) + " in string:\n" + _this.str + "\nat index " + _this.index + ". Errors were " + (JSON.stringify(errors, null, 4)));
              }
              return _this.optional(x[i], {
                args: args,
                notFound: function(err) {
                  return repeat(i + 1, errors.concat([err]));
                }
              });
            };
          };
        })(this));
      });
    } else if (util.typeOf(x) === "regexp") {
      return makeParser(name != null ? name : "regexp-form-parser: " + x, function() {
        var val;
        val = x.exec(this.str.slice(this.index));
        if (val === null) {
          return this["throw"]("Expected the regexp pattern " + x.toString() + (" in string ``" + this.str + "'' at index " + this.index));
        } else {
          return this.require(val[0]);
        }
      });
    } else if (util.typeOf(x) === "function") {
      if (x.isParser) {
        return makeParser(name != null ? name : "copy of: " + x.parserName, function() {
          return this.require(x);
        });
      } else {

        /* The parser (in the variable -parser-), can have the following arrangments of arguments:
                1. "string"
                2. ({string, startAt, args, found, notFound})
                3. (string, {startAt, args, found, notFound})
                4. (string, startAt, {args, found, notFound})
                5. (string, startAt, args, {found, notFound})
                6. (string, startAt, args, found, notFound)
         */
        useParserAbstraction = function(callback) {
          return function() {
            var args, other, startAt, str;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (args.length === 1) {
              if (util.typeOf(args[0]) === "string") {
                str = args[0];
              } else {
                str = args[0].lookFor;
                startAt = args[0].startAt;
                other = args[0];
              }
            } else if (args.length === 2) {
              str = args[0];
              if (util.typeOf(args[1]) === "object") {
                startAt = args[1].startAt;
                other = args[1];
              } else {
                startAt = args[1];
              }
            } else if (args.length === 3) {
              str = args[0];
              startAt = args[1];
              other = args[2];
            }
            return callback(str, startAt, other);
          };
        };
        parser = useParserAbstraction(function(str, startAt, other) {
          return parser.requireFor(makeParsingInstance(str, startAt), other);
        });
        parser.wholeStr = useParserAbstraction(function(str, startAt, other) {
          var parsingInstance, result;
          parsingInstance = makeParsingInstance(str, startAt);
          result = parser.requireFor(parsingInstance, other);
          if (parsingInstance.index !== parsingInstance.str.length) {
            throw parsingError("Expected end of string index " + parsingInstance.index + ".");
          } else {
            return result;
          }
        });
        parser.requireFor = function(origInstance, other) {
          var e, err, instance, val;
          if (other == null) {
            other = {};
          }
          if (util.typeOf(other.notFound) === "function") {
            instance = makeParsingInstance(origInstance.str, origInstance.index);
            try {
              val = x.call(instance, other.args);
            } catch (_error) {
              e = _error;
              if (isParsingError(e)) {
                err = e;
              } else {
                throw e;
              }
            }
            if (err) {
              return other.notFound(err);
            } else {
              if (!other.dontAdvance) {
                origInstance.index = instance.index;
              }
              if (other.found) {
                return other.found(val);
              } else {
                return val;
              }
            }
          } else {
            instance = makeParsingInstance(origInstance.str, origInstance.index);
            val = x.call(instance, other.args);
            if (!other.dontAdvance) {
              origInstance.index = instance.index;
            }
            if (other.found) {
              return other.found(val);
            } else {
              return val;
            }
          }
        };
        parser.makeNamed = function(name) {
          var newPrsr;
          return newPrsr = makeParser(name, function(args) {
            return this.require(parser, {
              args: args
            });
          });
        };
        parser["return"] = function(fn) {
          return makeParser(parser.parserName, function(args) {
            return this.require(parser, {
              args: args,
              found: fn
            });
          });
        };
        parser.then = function(x) {
          return makeParser(function() {
            this.require(parser);
            return this.require(x);
          });
        };
        parser.opt = function() {
          return makeParser(parser.parserName + "--opt", function() {
            return this.optional(parser);
          });
        };
        parser.isParser = true;
        parser.parserName = name != null ? name : "a parser";
        return Object.freeze(parser);
      }
    } else {
      throw new Error("The -makeParser- function requires argument(s).");
    }
  };

  makeParser.util = util;

  makeParser.seq = function() {
    var xs;
    xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return makeParser(function() {
      var findings;
      findings = [];
      return this.loop((function(_this) {
        return function(repeat) {
          return function(i) {
            if (i == null) {
              i = 0;
            }
            if (i < xs.length) {
              findings.push(_this.require(xs[i]));
              return repeat(i + 1);
            } else {
              findings.src = _this.soFar();
              return findings;
            }
          };
        };
      })(this));
    });
  };

  makeParser.many = function(x, other) {
    var parseInner;
    if (x == null) {
      throw new Error("Invalid first argument to makeParser.many: " + x);
    }
    if (util.typeOf(other.amt) === "number") {
      parseInner = makeParser(function(args) {
        var first, rest;
        if (args == null) {
          args = {};
        }
        if (args.amtLeft == null) {
          args.amtLeft = other != null ? other.amt : void 0;
        }
        if (args.amtLeft <= 0) {
          return [];
        } else {
          first = this.require(x);
          rest = [];
          if (args.amtLeft === 1) {
            return [first];
          } else {
            this.optional(function() {
              if (other != null ? other.sep : void 0) {
                this.require(other != null ? other.sep : void 0);
              }
              return rest = this.require(parseInner, {
                args: {
                  amtLeft: args.amtLeft - 1
                }
              });
            });
            return cons(first, rest);
          }
        }
      });
      return makeParser(function() {
        var findings;
        if (other != null ? other.start : void 0) {
          this.require(other.start);
        }
        findings = this.require(parseInner);
        if (other != null ? other.end : void 0) {
          this.require(other.end);
        }
        return findings;
      });
    } else {
      parseInner = makeParser(function() {
        var first, rest;
        first = this.require(x);
        rest = [];
        this.optional(function() {
          if (other != null ? other.sep : void 0) {
            this.require(other != null ? other.sep : void 0);
          }
          return rest = this.require(parseInner);
        });
        return cons(first, rest);
      });
      return makeParser(function() {
        var findings;
        if (other != null ? other.start : void 0) {
          this.require(other.start);
        }
        findings = (other != null ? other.allowEmpty : void 0) ? this.optional(parseInner) : this.require(parseInner);
        if (other != null ? other.end : void 0) {
          this.require(other.end);
        }
        return findings != null ? findings : [];
      });
    }
  };

  makeParser.cases = function(a, b) {
    var name, o;
    if (util.typeOf(a) === "string") {
      name = a;
      o = b;
    } else {
      o = a;
    }
    return makeParser(name, function() {
      return this.caseParse(o);
    });
  };

  makeParser.getWhite = makeParser("getWhite", /^[\s]+/);

  makeParser.jsonParsers = (function() {
    var getArray, getBoolean, getDigits, getJson, getNull, getNumber, getObject, getString;
    getString = makeParser("getString", function(args) {
      this.require('"');
      return this.loop((function(_this) {
        return function(repeat) {
          return function() {
            if (_this.char() === void 0) {
              _this["throw"]("Unterminated JSON string literal");
            }
            if (_this.char() === '"' && (_this.char(-1) !== "\\" || _this.char(-2) === "\\")) {
              _this.advance();
              return JSON.parse(_this.soFar());
            } else {
              _this.advance();
              return repeat();
            }
          };
        };
      })(this));
    });
    getDigits = makeParser("getDigits", /^[\d]+/);
    getNumber = makeParser("getNumber", function() {
      this.optional(["+", "-"]);
      this.require(getDigits);
      this.optional(function() {
        this.require(".");
        this.require(getDigits);
        return this.optional(function() {
          this.require("e");
          this.optional(["+", "-"]);
          return this.require(getDigits);
        });
      });
      return JSON.parse(this.soFar());
    });
    getBoolean = makeParser("getBoolean", function() {
      return this.caseParse({
        "true": function() {
          return true;
        },
        "false": function() {
          return false;
        }
      });
    });
    getNull = makeParser("getNull", "null")["return"](function() {
      return null;
    });
    getArray = (function() {
      var arrayBody;
      arrayBody = makeParser(function() {
        var fst;
        fst = this.require(getJson);
        this.white();
        return this.optional(",", {
          found: (function(_this) {
            return function() {
              var rest;
              _this.white();
              rest = _this.require(arrayBody);
              return cons(fst, rest);
            };
          })(this),
          notFound: (function(_this) {
            return function() {
              return [fst];
            };
          })(this)
        });
      });
      return makeParser("getArray", function() {
        var val;
        this.require("[");
        this.white();
        val = this.optional(arrayBody);
        this.white();
        this.require("]");
        return val != null ? val : [];
      });
    })();
    getObject = (function() {
      var getObjectBody, getObjectPair;
      getObjectPair = makeParser(function() {
        var prop, val;
        prop = this.require(string);
        this.require(":");
        this.white();
        val = this.require(getJson);
        return {
          "prop": prop,
          "val": val,
          "src": this.soFar()
        };
      });
      getObjectBody = makeParser(function() {
        return this.optional(getObjectPair, {
          found: (function(_this) {
            return function(fst) {
              var rest;
              rest = [];
              _this.optional(function() {
                this.white();
                this.require(",");
                this.white();
                return rest = this.require(getObjectBody);
              });
              return cons(fst, rest);
            };
          })(this),
          notFound: (function(_this) {
            return function() {
              return [];
            };
          })(this)
        });
      });
      return makeParser("getObject", function() {
        var obj, pairs;
        this.require("{");
        this.white();
        pairs = this.require(getObjectBody);
        this.white();
        this.require("}");
        obj = {};
        this.loop((function(_this) {
          return function(repeat) {
            return function(i) {
              if (i == null) {
                i = 0;
              }
              if (i < pairs.length) {
                obj[pairs[i].prop] = pairs[i].val;
                return repeat(i + 1);
              }
            };
          };
        })(this));
        return obj;
      });
    })();
    getJson = makeParser("getJson", [getNumber, getNull, getBoolean, getArray, getString, getObject]);
    return Object.freeze({
      "getJson": getJson,
      "getString": getString,
      "getNumber": getNumber,
      "getBoolean": getBoolean,
      "getNull": getNull,
      "getArray": getArray,
      "getObject": getObject
    });
  })();

  Object.freeze(makeParser);


  /* TODO: Things to THINK ABOUT for the future:
   -Allowing some easier way of creating parsers like ones from makeParser
     out of parsers which are just plain functions (i.e. some functions
     which create makeParser-parsers from something like JSON.parse).
   -Making parsers be objects (not functions) with these methods:
      "atStart": Just run the parser (equivalent to what a parser is now)
      "wholeStr": Runs the parser and makes sure that the content occupies the ENTIRE string (and there is no shit at the end of the string).
     or at least having the latter feature.
   -Make the "args" property of the options object in @require and @optional calls be an array of args
      rather than an object to be passed as the first arg.
   -ADDITIONALLY: Should makeParser record a stack so that when this error
      function is called, you can expand the error and observe which parsers
      were called, without having to look at the actual stack and just observing
      a bunch of calls to anonymous function or to `parser` or `requireFor` and
      shit?
   */

}).call(this);
